from collections import namedtuple
from datetime import datetime as dtt
from functools import partial
from inspect import signature, Parameter
import re
from typing import List, Generic, TypeVar
from pprint import pprint as pp

from marshmallow import Schema as BaseSchema
from marshmallow import fields, post_dump, post_load, missing


def kwsift(kw, f):
    '''
    Sifts a keyoword argument dictionary with respect to a function.
    Returns a dictionary with those entries that the given function
    accepts as keyword arguments.
    If the function is found to accept a variadic keyword dictionary
    (**kwargs), the first argument is returned unchanged, since any keyword
    argument is therefore legal.
    '''

    sig = signature(f)
    kw_kinds = {Parameter.KEYWORD_ONLY, Parameter.POSITIONAL_OR_KEYWORD}
    out = {}
    # go backward to catch **kwargs on the first pass
    for name, p in list(sig.parameters.items())[::-1]:
        if p.kind == p.VAR_KEYWORD:
            return kw
        elif p.kind in kw_kinds and name in kw.keys():
            out[name] = kw[name]

    return out


T = TypeVar('T')  # noqa


class URL:
    pass  # noqa


class Raw:
    pass  # noqa


class One(Generic[T]):
    pass  # noqa


class Many(Generic[T]):
    pass  # noqa


st_fieldspec = namedtuple(
    'fieldspec', ('default', 'type', 'req', 'allow_none'))


class Schema(BaseSchema):

    @post_load(pass_original=True)
    def load_extended(self, data, original_data):
        if isinstance(original_data, dict):
            extended_arguments = {
                k: v for k, v in original_data.items()
                if k.startswith('_') and not k.startswith('__')
            }

            if isinstance(data, dict):
                data["extended_arguments"] = extended_arguments

        return self.__model__(**data)

    @post_dump
    def dump_extended(self, data):
        extended = data.pop("extendedArguments", {})
        data.update(extended)
        return data


class ModelMeta(type):
    '''
    Metaclass factory for unified model/schema types.
    '''

    FIELD_TAB = {
        bool: fields.Boolean,
        str: fields.String,
        URL: fields.Url,
        int: fields.Integer,
        'nested': fields.Nested,
        'list': fields.List,
        dtt: partial(fields.DateTime, format='iso'),
        Raw: fields.Raw,
    }
    SCHEMA_ATTRNAME = '__schema__'
    MODEL_ATTRNAME = '__model__'

    @classmethod
    def get_schema_cls(typ, model_cls):
        try:
            return typ.FIELD_TAB[model_cls]
        except KeyError:
            sn = typ.get_schema_cls_name(model_cls)
            try:
                return getattr(model_cls, typ.SCHEMA_ATTRNAME)
            except AttributeError:
                raise ValueError(
                    '''{} does not appear to be a valid model, as it '
                    does not have an autogenerated Schema. Expected to find '
                    {} attribute, did not.'''.format(model_cls, sn))

    @classmethod
    def get_schema_cls_name(typ, model_cls):
        return model_cls.__name__ + 'Schema'

    @classmethod
    def sc_to_cc(typ, name):
        return re.sub(r'_([a-z])', lambda m: m.group(1).upper(), name)

    @classmethod
    def is_model_init(typ, init):
        return '_mro_offset' in signature(init).parameters.keys()

    def __new__(typ, model_name, bases, attrs, **mcs_kwargs):  # noqa
        '''
        Automatically generated schema fields for the model class.

        Uses keyword arguments given to init and their annotations to
        magically figure out what fields to add. Automatically converts to
        camelCase
        '''

        base_init = attrs['__init__']

        init_named_kwargs = {
            name: st_fieldspec(
                default=(
                    p.default if p.default is not Parameter.empty else None),
                type=p.annotation,
                req=p.default == p.empty,
                allow_none=p.default is None,
            )
            for name, p in signature(base_init).parameters.items()
            if p.kind == p.KEYWORD_ONLY
        }

        schema_attrs = {}

        for kwname, fspec in init_named_kwargs.items():
            field_args = []
            if issubclass(fspec.type, (Many, One, List)):
                key = 'nested' if not issubclass(fspec.type, List) else 'list'
                nested_type = typ.get_schema_cls(fspec.type.__args__[0])
                field_args.append(nested_type)
            else:
                key = fspec.type

            load_dump_to = attrs.get('irregular_names', {}).get(
                kwname, typ.sc_to_cc(kwname),
            )
            field = typ.FIELD_TAB[key](
                *field_args,
                default=fspec.default or missing,
                many=issubclass(fspec.type, (Many, List)),
                required=fspec.req,
                load_from=load_dump_to,
                dump_to=load_dump_to,
                allow_none=fspec.allow_none,
            )

            schema_attrs[kwname] = field

        model_cls = type(model_name, bases, attrs, **mcs_kwargs)

        schema_bases = tuple(
            getattr(model_cls, typ.SCHEMA_ATTRNAME, base) for base in bases)
        schema_bases = schema_bases + (Schema,)

        schema_cls = type(
            model_name + 'Schema',
            schema_bases,
            schema_attrs,
        )

        setattr(model_cls, typ.SCHEMA_ATTRNAME, schema_cls)
        setattr(schema_cls, typ.MODEL_ATTRNAME, model_cls)

        def model_init(model_obj, _mro_offset=1, **kwargs):
            '''
            Factor out the mindnumbing 'self.kwarg = kwarg' pattern.

            That should honestly be the default behaviour.
            '''

            # XXX: super(self.__class__, self).__init__ seems to fail
            # in a monkeypatched __init__ such as this one, forcing this kind
            # of manual __mro__ traversal. I'm sure something more sensible
            # can be done. This is the kind of stuff that gives metaprogramming
            # a bad name... blame super()'s super opacity
            model_cls = model_obj.__class__
            next_in_line = model_cls.__mro__[_mro_offset]

            if typ.is_model_init(next_in_line.__init__):
                next_in_line.__init__(
                    model_obj, _mro_offset=_mro_offset + 1,
                    **kwsift(kwargs, next_in_line.__init__),
                )
            elif next_in_line is not object:
                next_in_line.__init__(
                    model_obj, **kwsift(kwargs, next_in_line.__init__)
                )

            for kwname, fspec in init_named_kwargs.items():
                attr = kwargs.get(kwname, fspec.default)

                if issubclass(fspec.type, (Many, List)):
                    attr = attr or []
                if issubclass(fspec.type, Raw):
                    attr = attr or {}
                elif callable(fspec.default):
                    attr = attr or fspec.default()

                setattr(model_obj, kwname, attr)

            base_init(model_obj, **kwsift(kwargs, base_init))

        def model_dump(self, *args, **kwargs):
            strict = kwargs.pop('strict', True)
            schema_ins = self.__schema__(*args, strict=strict, **kwargs)
            return schema_ins.dump(self)

        @classmethod
        def model_load(cls, data, *args, **kwargs):
            strict = kwargs.pop('strict', True)
            schema_ins = cls.__schema__(*args, strict=strict, **kwargs)
            return schema_ins.load(data)

        model_cls.dump = model_dump
        model_cls.load = model_load
        model_cls.__init__ = model_init

        return model_cls


class Model(metaclass=ModelMeta):

    def __init__(
        self, *,
        extended_arguments: Raw=None,
        comment: str="") -> None: pass

    def __eq__(self, other):
        return (self.__class__ == other.__class__ and
                self.__dict__ == other.__dict__)

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, repr(self.__dict__))


class Cookie(Model, metaclass=ModelMeta):

    def __init__(
        self, *,
        name: str,
        value: str,
        path: str=None,
        domain: str=None,
        expires: dtt=None,
        http_only: bool=False,
        secure: bool=False) -> None: pass


class CacheState(Model, metaclass=ModelMeta):
    irregular_names = {'etag': 'eTag'}

    def __init__(
        self, *,
        expires: dtt=None,
        last_access: dtt=None,
        etag: str=None,
        hit_count: int=0,
        **kwargs) -> None: pass


class Cache(Model, metaclass=ModelMeta):

    def __init__(
        self, *,
        before_request: One[CacheState]=None,
        after_request: One[CacheState]=None,
        **kwargs) -> None: pass


class Content(Model, metaclass=ModelMeta):

    def __init__(
        self, *,
        size: int=-1,
        mime_type: str=None,
        text: str="",
        encoding: str=None,
        **kwargs) -> None: pass


class Timings(Model, metaclass=ModelMeta):

    def __init__(
        self, *,
        blocked: int=-1,
        dns: int=-1,
        connect: int=-1,
        send: int=-1,
        wait: int=-1,
        receive: int=-1,
        ssl: int=-1,
        **kwargs) -> None: pass


class Header(Model, metaclass=ModelMeta):

    def __init__(self, *, name: str, value: str, **kwargs) -> None: pass


class PostParam(Model, metaclass=ModelMeta):

    def __init__(
        self, *,
        name: str,
        value: str,
        file_name: str=None,
        content_type: str=None,
        **kwargs) -> None: pass


class PostData(Model, metaclass=ModelMeta):

    def __init__(
        self, *,
        mime_type: str=None,
        params: Many[PostParam]=None,
        text: str="",
        **kwargs) -> None: pass


class Param(Model, metaclass=ModelMeta):

    def __init__(self, *, name: str, value: str, **kwargs) -> None: pass


class Request(Model, metaclass=ModelMeta):

    def __init__(  # type: ignore
        self, *,
        method: str,
        url: URL,
        http_version: str="HTTP/1.0",
        cookies: Many[Cookie]=None,
        headers: Many[Header]=None,
        query_string: List[str]=None,
        post_data: One[PostData]=lambda: PostData(),
        header_size: int=-1,
        body_size: int=-1,
        **kwargs) -> None: pass


class Response(Model, metaclass=ModelMeta):
    irregular_names = {'redirect_url': 'redirectURL'}

    def __init__(
        self, *,
        status: int,
        status_text: str,
        http_version: str="HTTP/1.0",
        cookies: Many[Cookie]=None,
        headers: Many[Header]=None,
        content: One[Content]=None,
        redirect_url: URL=None,
        header_size: int=-1,
        body_size: int=-1) -> None: pass


class Creator(Model, metaclass=ModelMeta):

    def __init__(self, *, name: str, version: str, **kwargs) -> None: pass


class PageTimings(Model, metaclass=ModelMeta):

    def __init__(
        self, *,
        on_content_load: int=-1, on_load: int=-1, **kwargs) -> None: pass


class Page(Model, metaclass=ModelMeta):

    def __init__(
        self, *,
        id: str,
        title: str,
        started_date_time: dtt=None,
        page_timings: One[PageTimings]=None) -> None: pass


class Browser(Model, metaclass=ModelMeta):

    def __init__(self, *, name: str, version: str, **kwargs) -> None: pass


class Entry(Model, metaclass=ModelMeta):
    irregular_names = {
        'server_ip_address': 'serverIPAddress',
    }

    def __init__(
        self, *,
        pageref: str=None,
        started_date_time: dtt=None,
        time: int=-1,
        request: One[Request]=None,
        response: One[Response]=None,
        cache: One[Cache]=None,
        timings: One[Timings]=None,
        server_ip_address: str=None,
        connection: str=None,
        **kwargs) -> None: pass


class Log(Model, metaclass=ModelMeta):

    def __init__(
        self, *,
        version: str="1.1",
        creator: One[Creator]=None,
        browser: One[Browser]=None,
        pages: Many[Page]=None,
        entries: Many[Entry]=None,
        **kwargs) -> None: pass


class HAR(Model, metaclass=ModelMeta):

    def __init__(self, *, log: One[Log]=None, **kwargs) -> None:
        self.log = log or Log(**kwargs)


if __name__ == '__main__':
    from pprint import pprint as pp

    pd = PostData
